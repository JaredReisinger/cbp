// Auto-generated docs a la dep (but with bash explicitly called so that it
// also works on Windows).

//go:generate bash ./mkdoc.sh

package main

import (
	"bytes"
	"flag"
	"fmt"
	html "html/template"
	"io"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	text "text/template"
	"unicode"
)

var (
	name = "cbp"

	showHelp     = false
	showVersion  = false
	importPrefix = ""
	repoPrefix   = ""
	vcs          = "git"

	runServer    = true
	repoTemplate *html.Template
)

const usageStr = `
{{- .Name }} is a tool for simple Golang remote import path management.

Usage: {{ .Name }} -prefix IMPORT-PREFIX -root REPO-ROOT [-vcs VCS]]

{{ .Options }}

Examples:

    cbp -prefix go.example.org -root https://github.com/example

  Starts a cbp server that points requests for 'go.example.org/pkg' to
  'https://github.com/example/pkg'.
`

const addr = ":9090"

const repoInfo = `
<html>
  <head>
    <title>{{ .ImportPath }} - {{ .Name }} {{ .Version }}</title>
	<meta name="go-import" content="{{ .ImportPath}} {{ .VCS }} {{ .RepoPath }}" />
  </head>
  <body>
    <h1>{{ .ImportPath }}</h1>
	<ul>
	  <li>VCS: {{ .VCS }}</li>
	  <li>Repo Root: {{ .RepoPath }}</li>
	</ul>
  </body>
</html>
`

func main() {
	// If we want to use dep-style auto-generated docs, building with a
	// different name will result in the wrong name in the docs!
	// name = filepath.Base(os.Args[0])

	flag.BoolVar(&showHelp, "help", showHelp, "show help")
	flag.BoolVar(&showVersion, "version", showVersion, "show the version")
	flag.StringVar(&importPrefix, "prefix", "", "the `import-prefix` hostname for the custom import path")
	flag.StringVar(&repoPrefix, "root", "", "the actual hosting repo for the custom import path")
	flag.StringVar(&vcs, "vcs", vcs, "the VCS for the repos")

	flag.Parse()

	if showHelp {
		usage()
		return
	}

	if showVersion {
		printVersion()
		return
	}

	// ensure any trailing slashes have been removed from importPrefix and
	// repoPrefix... the calculated paths will *always* start with a slash.
	importPrefix = strings.TrimRight(importPrefix, "/")
	repoPrefix = strings.TrimRight(repoPrefix, "/")

	if importPrefix == "" {
		fmt.Println("missing required value: -import-path")
		showHelp = true
	}

	if repoPrefix == "" {
		fmt.Println("missing required value: -repo-prefix")
		showHelp = true
	}

	if vcs == "" {
		fmt.Println("missing required value: -vcs")
		showHelp = true
	}

	// if we've gotten this far and showHelp is set, there's been an error.
	if showHelp {
		fmt.Println("")
		usage()
		os.Exit(-1)
	}

	repoTemplate = html.Must(html.New("repoInfo").Parse(repoInfo))

	log.Printf("Starting %s at \"%s\"...", name, addr)

	http.HandleFunc("/", serveMeta)
	http.Handle("/favicon.ico", http.NotFoundHandler())
	log.Fatal(http.ListenAndServe(addr, nil))
}

func usage() {
	w := io.Writer(os.Stderr)
	// detect if this is the doc-helper special case...
	docs := filepath.Base(os.Args[0]) == "doc-helper"

	if docs {
		fmt.Println("// Copyright 2018 Jared Reisinger. All rights reserved.")
		fmt.Println("// DO NOT EDIT THIS FILE. GENERATED BY mkdoc.sh.")
		fmt.Println("")

		w = &commentWriter{W: os.Stdout}
	}

	// capture the flag usage...
	b := &bytes.Buffer{}
	flag.CommandLine.SetOutput(b)
	flag.PrintDefaults()
	options := strings.TrimRightFunc(b.String(), unicode.IsSpace)

	usageTemplate := text.Must(text.New("usage").Parse(usageStr))
	usageTemplate.Execute(w, map[string]string{
		"Name":    name,
		"Version": version,
		"Options": options,
	})

	if docs {
		fmt.Println("package main")
	}
}

func serveMeta(w http.ResponseWriter, r *http.Request) {
	pathPrefix := r.URL.Path

	// Remember that real requests always start with "/", so we ignore that
	// character.  Also, we split into 3 since we don't use anything past the
	// second component.
	parts := strings.SplitN(pathPrefix[1:], "/", 3)

	// For zero, one, or two parts, the existing prefix (path) is good.  For
	// anything longer, we shorten it to just the first two (org/repo).
	if len(parts) > 2 {
		pathPrefix = fmt.Sprintf("/%s", strings.Join(parts[:2], "/"))
	}

	importPath := fmt.Sprintf("%s%s", importPrefix, r.URL.Path)
	repoPath := fmt.Sprintf("%s%s", repoPrefix, pathPrefix)

	log.Printf("%s => %s", importPath, repoPath)

	repoTemplate.Execute(w, map[string]string{
		"Name":       name,
		"Version":    version,
		"ImportPath": importPath,
		"VCS":        vcs,
		"RepoPath":   repoPath,
	})
}

// commentWriter writes a Go comment to the underlying io.Writer,
// using line comment form (//).
//
// Copied from cmd/go/internal/help/help.go.
type commentWriter struct {
	W            io.Writer
	wroteSlashes bool // Wrote "//" at the beginning of the current line.
}

func (c *commentWriter) Write(p []byte) (int, error) {
	var n int
	for i, b := range p {
		if !c.wroteSlashes {
			s := "//"
			if b != '\n' {
				s = "// "
			}
			if _, err := io.WriteString(c.W, s); err != nil {
				return n, err
			}
			c.wroteSlashes = true
		}
		n0, err := c.W.Write(p[i : i+1])
		n += n0
		if err != nil {
			return n, err
		}
		if b == '\n' {
			c.wroteSlashes = false
		}
	}
	return len(p), nil
}
